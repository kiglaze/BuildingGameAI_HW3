#include "SpriteCollection.h"
#include "Sprite.h"

SpriteCollection::SpriteCollection(std::vector<Crumb>* crumbs)
: breadcrumbs(crumbs) { // Use initializer list here
}

SpriteCollection::~SpriteCollection() {
    // Iterate through the vector and delete all Sprite objects
    for (auto& sprite : sprites) {
        delete sprite; // Delete the dynamically allocated Sprite object
    }
    sprites.clear(); // Clear the vector to remove all the pointers
}

void SpriteCollection::allSpritesDropCrumbs() {
    if (drop_timer > 0)
    {
        drop_timer = drop_timer - 0.1f;
    }
    else
    {
        drop_timer = 15.f;
        for (auto& sprite : sprites) {
            if (sprite != nullptr) {
                bc_position = sprite->getPosition();
                breadcrumbs->at(crumb_idx).drop(bc_position);

                if (crumb_idx < 54)
                    crumb_idx++;
                else
                    crumb_idx = 0;
            }
        }
    }
}

void SpriteCollection::addSprite(Sprite* sprite) {
    sprites.push_back(sprite);
}

// Remove the specified sprite.
// This removeSprites code was generated by ChatGPT.
void SpriteCollection::removeSprite(Sprite* sprite) {
    auto it = std::find(sprites.begin(), sprites.end(), sprite);
    if (it != sprites.end()) {
        delete *it; // Delete the sprite
        sprites.erase(it); // Remove the pointer from the collection
    }
}

// Draw all the sprites to the window.
void SpriteCollection::drawAll(sf::RenderWindow& window) {
    for (auto& sprite : sprites) {
        if (sprite != nullptr) {
            sprite->draw(window);
        }
    }
}

// Return the count of all the sprites.
std::size_t SpriteCollection::getSpriteCount() {
    return sprites.size();
}

// Add a new sprite to the starting position.
void SpriteCollection::addStartingSprite(std::string textureFilePath, int isLeader) {
    Sprite* spriteA = new Sprite(textureFilePath, 25.f, 25.f, 0, sf::Vector2f(0, 0), 0, isLeader, breadcrumbs);
    addSprite(spriteA);
}

// Get all the pointers to sprites.
const std::vector<Sprite*>& SpriteCollection::getSprites() const {
    return sprites;
}

sf::Vector2f SpriteCollection::getCOMPosition() {
    std::vector<Sprite*> allSprites = getSprites();
    int allSpritesCount = getSpriteCount();
    float sumXPosVal = 0;
    float sumYPosVal = 0;
    for (Sprite* sprite : allSprites) {
        sf::Vector2f spritePosVect = sprite->getPosition();
        sumXPosVal += spritePosVect.x;
        sumYPosVal += spritePosVect.y;
    }
    return sf::Vector2f((sumXPosVal/allSpritesCount), (sumYPosVal/allSpritesCount));
}
sf::Vector2f SpriteCollection::getCOMVelocityVector() {
    std::vector<Sprite*> allSprites = getSprites();
    int allSpritesCount = getSpriteCount();
    
    // Initialize sums for velocity components
    float sumXVel = 0;
    float sumYVel = 0;
    
    // Loop through all sprites to sum up their velocity vectors
    for (Sprite* sprite : allSprites) {
        sf::Vector2f spriteVelVect = sprite->getVelocityVector();
        sumXVel += spriteVelVect.x;
        sumYVel += spriteVelVect.y;
    }
    
    // Calculate averages
    float avgXVel = allSpritesCount > 0 ? sumXVel / allSpritesCount : 0;
    float avgYVel = allSpritesCount > 0 ? sumYVel / allSpritesCount : 0;
    
    // Return the average velocity vector
    return sf::Vector2f(avgXVel, avgYVel);
}

// Delete all sprites that are marked for deletion.
void SpriteCollection::deleteMarkedSprites() {
    const std::vector<Sprite*>& allSprites = getSprites();

    for (Sprite* sprite : allSprites) {
        if (sprite != nullptr && sprite->shouldBeDeleted() == 1) {
            removeSprite(sprite);
        }
    }
}
